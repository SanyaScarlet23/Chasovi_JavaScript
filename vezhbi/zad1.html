<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script type="text/javascript" src="zad1.js"></script>
</head>
<body>
    <!--
        1. Vnesete dvocifren broj preku prompt i ispecatete go brojot kako zbori. primer: 23- dva tri, 57- pet sedum
        //za doma: da procitate kako funkcioniraat objektite vo javascript
_____OBJECTS_______
The Object type represents one of JavaScript's data types. 
It is used to store various keyed collections and more complex entities.
 Objects can be created using the Object() constructor or the object initializer / literal syntax.
As we know from the chapter Data types, there are eight data types in JavaScript. Seven of them are called “primitive”, 
because their values contain only a single thing (be it a string or a number or whatever).
In contrast, objects are used to store keyed collections of various data and more complex entities.
 In JavaScript, objects penetrate almost every aspect of the language. So we must understand them first before going in-depth anywhere else.
An object can be created with figure brackets {…} with an optional list of properties. 
A property is a “key: value” pair, where key is a string (also called a “property name”), and value can be anything.
We can imagine an object as a cabinet with signed files. Every piece of data is stored in its file by the key.
It’s easy to find a file by its name or add/remove a file.
An empty object (“empty cabinet”) can be created using one of two syntaxes:
let user = new Object(); // "object constructor" syntax
let user = {};  // "object literal" syntax

Usually, the figure brackets {...} are used. That declaration is called an object literal.
Literals and properties
We can immediately put some properties into {...} as “key: value” pairs:

let user = {     // an object
  name: "John",  // by key "name" store value "John"
  age: 30        // by key "age" store value 30
};
A property has a key (also known as “name” or “identifier”) before the colon ":" and a value to the right of it.

In the user object, there are two properties:

The first property has the name "name" and the value "John".
The second one has the name "age" and the value 30.
The resulting user object can be imagined as a cabinet with two signed files labeled “name” and “age”.


We can add, remove and read files from it at any time.

Property values are accessible using the dot notation:

// get property values of the object:
alert( user.name ); // John
alert( user.age ); // 30
The value can be of any type. Let’s add a boolean one:

user.isAdmin = true;

To remove a property, we can use the delete operator:

delete user.age;

We can also use multiword property names, but then they must be quoted:

let user = {
  name: "John",
  age: 30,
  "likes birds": true  // multiword property name must be quoted
};

The last property in the list may end with a comma:

let user = {
  name: "John",
  age: 30,
}
That is called a “trailing” or “hanging” comma. Makes it easier to add/remove/move around properties, because all lines become alike.
______DESCRIPTION_______
Nearly all objects in JavaScript are instances of Object; 
a typical object inherits properties (including methods) from Object.prototype, although these properties may be shadowed (a.k.a. overridden). 
The only objects that don't inherit from Object.prototype are those with null prototype, or descended from other null prototype objects.

Changes to the Object.prototype object are seen by all objects through prototype chaining, 
unless the properties and methods subject to those changes are overridden further along the prototype chain. 
This provides a very powerful although potentially dangerous mechanism to override or extend object behavior. 
To make it more secure, Object.prototype is the only object 
in the core JavaScript language that has immutable prototype — the prototype of Object.prototype is always null and not changeable.

__________OBJECT PROTOTYPE PROPERTIES_________________
You should avoid calling any Object.prototype method, especially those that are not intended to be polymorphic
 (i.e. only its initial behavior makes sense and no descending object could override it in a meaningful way).
  All objects descending from Object.prototype may define a custom own property that has the same name, 
  but with entirely different semantics from what you expect. Furthermore, these properties are not inherited by null-prototype objects.
   All modern JavaScript utilities for working with objects are static. More specifically:

1. valueOf(), toString(), and toLocaleString() exist to be polymorphic and you should expect the object to define its own implementation with sensible behaviors, 
so you can call them as instance methods. However, valueOf() and toString() are 
usually implicitly called through type conversion and you don't need to call them yourself in your code.
2.  __defineGetter__(), __defineSetter__(), __lookupGetter__(), and __lookupSetter__() are deprecated and should not be used.
        Use the static alternatives Object.defineProperty() and Object.getOwnPropertyDescriptor() instead.
3.  The __proto__ property is deprecated and should not be used. The Object.getPrototypeOf() and Object.setPrototypeOf() alternatives are static methods.
4.  The propertyIsEnumerable() and hasOwnProperty() methods can be replaced with the Object.getOwnPropertyDescriptor() and Object.hasOwn() static methods, respectively.
5.  The isPrototypeOf() method can usually be replaced with instanceof, if you are checking the prototype property of a constructor.

In case where a semantically equivalent static method doesn't exist, or if you really want to use the Object.prototype method, 
you should directly call() the Object.prototype method on your target object instead, 
to prevent the object from having an overriding property that produces unexpected results.
    -->
</body>
</html>